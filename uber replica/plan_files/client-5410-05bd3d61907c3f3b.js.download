(self.webpackChunkFusion=self.webpackChunkFusion||[]).push([[5410],{75109:(e,t,i)=>{"use strict";i.d(t,{Z:()=>y});var n=i(97455),o=i(51007),s=i(17731),r=i(57891),a=i(93742),l=i(55478),c=i(62492),d=i(47077),u=i(22519),h=i(99);class p extends d.Z{constructor(e){super({...e,attributes:{positions:{size:3,padding:18,initialize:!0,type:e.fp64?Float64Array:Float32Array},segmentTypes:{size:1,type:Uint8ClampedArray}}})}get(e){return this.attributes[e]}getGeometryFromBuffer(e){return this.normalize?super.getGeometryFromBuffer(e):null}normalizeGeometry(e){return this.normalize?function(e,t,i,n){let o;if(Array.isArray(e[0])){const i=e.length*t;o=new Array(i);for(let i=0;i<e.length;i++)for(let n=0;n<t;n++)o[i*t+n]=e[i][n]||0}else o=e;return i?(0,u.d)(o,{size:t,gridResolution:i}):n?(0,h.c)(o,{size:t}):o}(e,this.positionSize,this.opts.resolution,this.opts.wrapLongitude):e}getGeometrySize(e){if(g(e)){let t=0;for(const i of e)t+=this.getGeometrySize(i);return t}const t=this.getPathLength(e);return t<2?0:this.isClosed(e)?t<3?0:t+2:t}updateGeometryAttributes(e,t){if(0!==t.geometrySize)if(e&&g(e))for(const i of e){const e=this.getGeometrySize(i);t.geometrySize=e,this.updateGeometryAttributes(i,t),t.vertexStart+=e}else this._updateSegmentTypes(e,t),this._updatePositions(e,t)}_updateSegmentTypes(e,t){const i=this.attributes.segmentTypes,n=!!e&&this.isClosed(e),{vertexStart:o,geometrySize:s}=t;i.fill(0,o,o+s),n?(i[o]=4,i[o+s-2]=4):(i[o]+=1,i[o+s-2]+=2),i[o+s-1]=4}_updatePositions(e,t){const{positions:i}=this.attributes;if(!i||!e)return;const{vertexStart:n,geometrySize:o}=t,s=new Array(3);for(let t=n,r=0;r<o;t++,r++)this.getPointOnPath(e,r,s),i[3*t]=s[0],i[3*t+1]=s[1],i[3*t+2]=s[2]}getPathLength(e){return e.length/this.positionSize}getPointOnPath(e,t){let i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[];const{positionSize:n}=this;t*n>=e.length&&(t+=1-e.length/n);const o=t*n;return i[0]=e[o],i[1]=e[o+1],i[2]=3===n&&e[o+2]||0,i}isClosed(e){if(!this.normalize)return Boolean(this.opts.loop);const{positionSize:t}=this,i=e.length-t;return e[0]===e[i]&&e[1]===e[i+1]&&(2===t||e[2]===e[i+2])}}function g(e){return Array.isArray(e[0])}const f=[0,0,0,255],m={widthUnits:"meters",widthScale:{type:"number",min:0,value:1},widthMinPixels:{type:"number",min:0,value:0},widthMaxPixels:{type:"number",min:0,value:Number.MAX_SAFE_INTEGER},jointRounded:!1,capRounded:!1,miterLimit:{type:"number",min:0,value:4},billboard:!1,_pathType:null,getPath:{type:"accessor",value:e=>e.path},getColor:{type:"accessor",value:f},getWidth:{type:"accessor",value:1},rounded:{deprecatedFor:["jointRounded","capRounded"]}},v={enter:(e,t)=>t.length?t.subarray(t.length-e.length):e};class y extends o.Z{constructor(){super(...arguments),(0,n.Z)(this,"state",void 0)}getShaders(){return super.getShaders({vs:"#define SHADER_NAME path-layer-vertex-shader\n\nattribute vec2 positions;\n\nattribute float instanceTypes;\nattribute vec3 instanceStartPositions;\nattribute vec3 instanceEndPositions;\nattribute vec3 instanceLeftPositions;\nattribute vec3 instanceRightPositions;\nattribute vec3 instanceLeftPositions64Low;\nattribute vec3 instanceStartPositions64Low;\nattribute vec3 instanceEndPositions64Low;\nattribute vec3 instanceRightPositions64Low;\nattribute float instanceStrokeWidths;\nattribute vec4 instanceColors;\nattribute vec3 instancePickingColors;\n\nuniform float widthScale;\nuniform float widthMinPixels;\nuniform float widthMaxPixels;\nuniform float jointType;\nuniform float capType;\nuniform float miterLimit;\nuniform bool billboard;\nuniform int widthUnits;\n\nuniform float opacity;\n\nvarying vec4 vColor;\nvarying vec2 vCornerOffset;\nvarying float vMiterLength;\nvarying vec2 vPathPosition;\nvarying float vPathLength;\nvarying float vJointType;\n\nconst float EPSILON = 0.001;\nconst vec3 ZERO_OFFSET = vec3(0.0);\n\nfloat flipIfTrue(bool flag) {\n  return -(float(flag) * 2. - 1.);\n}\n\n// calculate line join positions\nvec3 lineJoin(\n  vec3 prevPoint, vec3 currPoint, vec3 nextPoint,\n  vec2 width\n) {\n  bool isEnd = positions.x > 0.0;\n  // side of the segment - -1: left, 0: center, 1: right\n  float sideOfPath = positions.y;\n  float isJoint = float(sideOfPath == 0.0);\n\n  vec3 deltaA3 = (currPoint - prevPoint);\n  vec3 deltaB3 = (nextPoint - currPoint);\n\n  mat3 rotationMatrix;\n  bool needsRotation = !billboard && project_needs_rotation(currPoint, rotationMatrix);\n  if (needsRotation) {\n    deltaA3 = deltaA3 * rotationMatrix;\n    deltaB3 = deltaB3 * rotationMatrix;\n  }\n  vec2 deltaA = deltaA3.xy / width;\n  vec2 deltaB = deltaB3.xy / width;\n\n  float lenA = length(deltaA);\n  float lenB = length(deltaB);\n\n  vec2 dirA = lenA > 0. ? normalize(deltaA) : vec2(0.0, 0.0);\n  vec2 dirB = lenB > 0. ? normalize(deltaB) : vec2(0.0, 0.0);\n\n  vec2 perpA = vec2(-dirA.y, dirA.x);\n  vec2 perpB = vec2(-dirB.y, dirB.x);\n\n  // tangent of the corner\n  vec2 tangent = dirA + dirB;\n  tangent = length(tangent) > 0. ? normalize(tangent) : perpA;\n  // direction of the corner\n  vec2 miterVec = vec2(-tangent.y, tangent.x);\n  // direction of the segment\n  vec2 dir = isEnd ? dirA : dirB;\n  // direction of the extrusion\n  vec2 perp = isEnd ? perpA : perpB;\n  // length of the segment\n  float L = isEnd ? lenA : lenB;\n\n  // A = angle of the corner\n  float sinHalfA = abs(dot(miterVec, perp));\n  float cosHalfA = abs(dot(dirA, miterVec));\n\n  // -1: right, 1: left\n  float turnDirection = flipIfTrue(dirA.x * dirB.y >= dirA.y * dirB.x);\n\n  // relative position to the corner:\n  // -1: inside (smaller side of the angle)\n  // 0: center\n  // 1: outside (bigger side of the angle)\n  float cornerPosition = sideOfPath * turnDirection;\n\n  float miterSize = 1.0 / max(sinHalfA, EPSILON);\n  // trim if inside corner extends further than the line segment\n  miterSize = mix(\n    min(miterSize, max(lenA, lenB) / max(cosHalfA, EPSILON)),\n    miterSize,\n    step(0.0, cornerPosition)\n  );\n\n  vec2 offsetVec = mix(miterVec * miterSize, perp, step(0.5, cornerPosition))\n    * (sideOfPath + isJoint * turnDirection);\n\n  // special treatment for start cap and end cap\n  bool isStartCap = lenA == 0.0 || (!isEnd && (instanceTypes == 1.0 || instanceTypes == 3.0));\n  bool isEndCap = lenB == 0.0 || (isEnd && (instanceTypes == 2.0 || instanceTypes == 3.0));\n  bool isCap = isStartCap || isEndCap;\n\n  // extend out a triangle to envelope the round cap\n  if (isCap) {\n    offsetVec = mix(perp * sideOfPath, dir * capType * 4.0 * flipIfTrue(isStartCap), isJoint);\n    vJointType = capType;\n  } else {\n    vJointType = jointType;\n  }\n\n  // Generate variables for fragment shader\n  vPathLength = L;\n  vCornerOffset = offsetVec;\n  vMiterLength = dot(vCornerOffset, miterVec * turnDirection);\n  vMiterLength = isCap ? isJoint : vMiterLength;\n\n  vec2 offsetFromStartOfPath = vCornerOffset + deltaA * float(isEnd);\n  vPathPosition = vec2(\n    dot(offsetFromStartOfPath, perp),\n    dot(offsetFromStartOfPath, dir)\n  );\n  geometry.uv = vPathPosition;\n\n  float isValid = step(instanceTypes, 3.5);\n  vec3 offset = vec3(offsetVec * width * isValid, 0.0);\n\n  if (needsRotation) {\n    offset = rotationMatrix * offset;\n  }\n  return currPoint + offset;\n}\n\n// In clipspace extrusion, if a line extends behind the camera, clip it to avoid visual artifacts\nvoid clipLine(inout vec4 position, vec4 refPosition) {\n  if (position.w < EPSILON) {\n    float r = (EPSILON - refPosition.w) / (position.w - refPosition.w);\n    position = refPosition + (position - refPosition) * r;\n  }\n}\n\nvoid main() {\n  geometry.pickingColor = instancePickingColors;\n\n  vColor = vec4(instanceColors.rgb, instanceColors.a * opacity);\n\n  float isEnd = positions.x;\n\n  vec3 prevPosition = mix(instanceLeftPositions, instanceStartPositions, isEnd);\n  vec3 prevPosition64Low = mix(instanceLeftPositions64Low, instanceStartPositions64Low, isEnd);\n\n  vec3 currPosition = mix(instanceStartPositions, instanceEndPositions, isEnd);\n  vec3 currPosition64Low = mix(instanceStartPositions64Low, instanceEndPositions64Low, isEnd);\n\n  vec3 nextPosition = mix(instanceEndPositions, instanceRightPositions, isEnd);\n  vec3 nextPosition64Low = mix(instanceEndPositions64Low, instanceRightPositions64Low, isEnd);\n\n  geometry.worldPosition = currPosition;\n  vec2 widthPixels = vec2(clamp(\n    project_size_to_pixel(instanceStrokeWidths * widthScale, widthUnits),\n    widthMinPixels, widthMaxPixels) / 2.0);\n  vec3 width;\n\n  if (billboard) {\n    // Extrude in clipspace\n    vec4 prevPositionScreen = project_position_to_clipspace(prevPosition, prevPosition64Low, ZERO_OFFSET);\n    vec4 currPositionScreen = project_position_to_clipspace(currPosition, currPosition64Low, ZERO_OFFSET, geometry.position);\n    vec4 nextPositionScreen = project_position_to_clipspace(nextPosition, nextPosition64Low, ZERO_OFFSET);\n\n    clipLine(prevPositionScreen, currPositionScreen);\n    clipLine(nextPositionScreen, currPositionScreen);\n    clipLine(currPositionScreen, mix(nextPositionScreen, prevPositionScreen, isEnd));\n\n    width = vec3(widthPixels, 0.0);\n    DECKGL_FILTER_SIZE(width, geometry);\n\n    vec3 pos = lineJoin(\n      prevPositionScreen.xyz / prevPositionScreen.w,\n      currPositionScreen.xyz / currPositionScreen.w,\n      nextPositionScreen.xyz / nextPositionScreen.w,\n      project_pixel_size_to_clipspace(width.xy)\n    );\n\n    gl_Position = vec4(pos * currPositionScreen.w, currPositionScreen.w);\n  } else {\n    // Extrude in commonspace\n    prevPosition = project_position(prevPosition, prevPosition64Low);\n    currPosition = project_position(currPosition, currPosition64Low);\n    nextPosition = project_position(nextPosition, nextPosition64Low);\n\n    width = vec3(project_pixel_size(widthPixels), 0.0);\n    DECKGL_FILTER_SIZE(width, geometry);\n\n    vec4 pos = vec4(\n      lineJoin(prevPosition, currPosition, nextPosition, width.xy),\n      1.0);\n    geometry.position = pos;\n    gl_Position = project_common_position_to_clipspace(pos);\n  }\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n  DECKGL_FILTER_COLOR(vColor, geometry);\n}\n",fs:"#define SHADER_NAME path-layer-fragment-shader\n\nprecision highp float;\n\nuniform float miterLimit;\n\nvarying vec4 vColor;\nvarying vec2 vCornerOffset;\nvarying float vMiterLength;\n/*\n * vPathPosition represents the relative coordinates of the current fragment on the path segment.\n * vPathPosition.x - position along the width of the path, between [-1, 1]. 0 is the center line.\n * vPathPosition.y - position along the length of the path, between [0, L / width].\n */\nvarying vec2 vPathPosition;\nvarying float vPathLength;\nvarying float vJointType;\n\nvoid main(void) {\n  geometry.uv = vPathPosition;\n\n  if (vPathPosition.y < 0.0 || vPathPosition.y > vPathLength) {\n    // if joint is rounded, test distance from the corner\n    if (vJointType > 0.5 && length(vCornerOffset) > 1.0) {\n      discard;\n    }\n    // trim miter\n    if (vJointType < 0.5 && vMiterLength > miterLimit + 1.0) {\n      discard;\n    }\n  }\n  gl_FragColor = vColor;\n\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n",modules:[s.Z,r.Z]})}get wrapLongitude(){return!1}initializeState(){this.getAttributeManager().addInstanced({positions:{size:3,vertexOffset:1,type:5130,fp64:this.use64bitPositions(),transition:v,accessor:"getPath",update:this.calculatePositions,noAlloc:true,shaderAttributes:{instanceLeftPositions:{vertexOffset:0},instanceStartPositions:{vertexOffset:1},instanceEndPositions:{vertexOffset:2},instanceRightPositions:{vertexOffset:3}}},instanceTypes:{size:1,type:5121,update:this.calculateSegmentTypes,noAlloc:true},instanceStrokeWidths:{size:1,accessor:"getWidth",transition:v,defaultValue:1},instanceColors:{size:this.props.colorFormat.length,type:5121,normalized:!0,accessor:"getColor",transition:v,defaultValue:f},instancePickingColors:{size:3,type:5121,accessor:(e,t)=>{let{index:i,target:n}=t;return this.encodePickingColor(e&&e.__source?e.__source.index:i,n)}}}),this.setState({pathTesselator:new p({fp64:this.use64bitPositions()})})}updateState(e){super.updateState(e);const{props:t,changeFlags:i}=e,n=this.getAttributeManager();if(i.dataChanged||i.updateTriggersChanged&&(i.updateTriggersChanged.all||i.updateTriggersChanged.getPath)){const{pathTesselator:e}=this.state,o=t.data.attributes||{};e.updateGeometry({data:t.data,geometryBuffer:o.getPath,buffers:o,normalize:!t._pathType,loop:"loop"===t._pathType,getGeometry:t.getPath,positionFormat:t.positionFormat,wrapLongitude:t.wrapLongitude,resolution:this.context.viewport.resolution,dataChanged:i.dataChanged}),this.setState({numInstances:e.instanceCount,startIndices:e.vertexStarts}),i.dataChanged||n.invalidateAll()}if(i.extensionsChanged){var o;const{gl:e}=this.context;null===(o=this.state.model)||void 0===o||o.delete(),this.state.model=this._getModel(e),n.invalidateAll()}}getPickingInfo(e){const t=super.getPickingInfo(e),{index:i}=t,{data:n}=this.props;return n[0]&&n[0].__source&&(t.object=n.find((e=>e.__source.index===i))),t}disablePickingIndex(e){const{data:t}=this.props;if(t[0]&&t[0].__source)for(let i=0;i<t.length;i++)t[i].__source.index===e&&this._disablePickingIndex(i);else this._disablePickingIndex(e)}draw(e){let{uniforms:t}=e;const{jointRounded:i,capRounded:n,billboard:o,miterLimit:s,widthUnits:r,widthScale:l,widthMinPixels:c,widthMaxPixels:d}=this.props;this.state.model.setUniforms(t).setUniforms({jointType:Number(i),capType:Number(n),billboard:o,widthUnits:a.iI[r],widthScale:l,miterLimit:s,widthMinPixels:c,widthMaxPixels:d}).draw()}_getModel(e){return new l.Z(e,{...this.getShaders(),id:this.props.id,geometry:new c.Z({drawMode:4,attributes:{indices:new Uint16Array([0,1,2,1,4,2,1,3,4,3,5,4]),positions:{value:new Float32Array([0,0,0,-1,0,1,1,-1,1,1,1,0]),size:2}}}),isInstanced:!0})}calculatePositions(e){const{pathTesselator:t}=this.state;e.startIndices=t.vertexStarts,e.value=t.get("positions")}calculateSegmentTypes(e){const{pathTesselator:t}=this.state;e.startIndices=t.vertexStarts,e.value=t.get("segmentTypes")}}(0,n.Z)(y,"defaultProps",m),(0,n.Z)(y,"layerName","PathLayer")},9214:(e,t,i)=>{"use strict";i.d(t,{Z:()=>U});var n=i(97455),o=i(74129),s=i(33620),r=i(50437),a=i(51007),l=i(17731),c=i(94998),d=i(57891),u=i(93742),h=i(67900),p=i(70217),g=i(55478),f=i(62492),m=i(68685),v=i.n(m),y=i(60599);const P=y.wG.CLOCKWISE,x=y.wG.COUNTER_CLOCKWISE,w={isClosed:!0};function b(e){return"positions"in e?e.positions:e}function C(e){return"holeIndices"in e?e.holeIndices:null}function S(e,t,i,n){for(let o=0;o<t;o++)if(e[i+o]!==e[n-t+o])return!1;return!0}function L(e,t,i,n,o){let s=t;const r=i.length;for(let t=0;t<r;t++)for(let o=0;o<n;o++)e[s++]=i[t][o]||0;if(!function(e){const t=e[0],i=e[e.length-1];return t[0]===i[0]&&t[1]===i[1]&&t[2]===i[2]}(i))for(let t=0;t<n;t++)e[s++]=i[0][t]||0;return w.start=t,w.end=s,w.size=n,(0,y.Ny)(e,o,w),s}function _(e,t,i,n){let o=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,s=arguments.length>5?arguments[5]:void 0,r=arguments.length>6?arguments[6]:void 0;s=s||i.length;const a=s-o;if(a<=0)return t;let l=t;for(let t=0;t<a;t++)e[l++]=i[o+t];if(!S(i,n,o,s))for(let t=0;t<n;t++)e[l++]=i[o+t];return w.start=t,w.end=l,w.size=n,(0,y.Ny)(e,r,w),l}function E(e,t){!function(e){if(e=e&&e.positions||e,!Array.isArray(e)&&!ArrayBuffer.isView(e))throw new Error("invalid polygon")}(e);const i=[],n=[];if("positions"in e){const{positions:o,holeIndices:s}=e;if(s){let e=0;for(let r=0;r<=s.length;r++)e=_(i,e,o,t,s[r-1],s[r],0===r?P:x),n.push(e);return n.pop(),{positions:i,holeIndices:n}}e=o}if(!function(e){return Array.isArray(e[0])}(e))return _(i,0,e,t,0,i.length,P),i;if(!function(e){return e.length>=1&&e[0].length>=2&&Number.isFinite(e[0][0])}(e)){let o=0;for(const[s,r]of e.entries())o=L(i,o,r,t,0===s?P:x),n.push(o);return n.pop(),{positions:i,holeIndices:n}}return L(i,0,e,t,P),i}var T=i(47077),O=i(22519),I=i(99);class M extends T.Z{constructor(e){const{fp64:t,IndexType:i=Uint32Array}=e;super({...e,attributes:{positions:{size:3,type:t?Float64Array:Float32Array},vertexValid:{type:Uint8ClampedArray,size:1},indices:{type:i,size:1}}})}get(e){const{attributes:t}=this;return"indices"===e?t.indices&&t.indices.subarray(0,this.vertexCount):t[e]}updateGeometry(e){super.updateGeometry(e);const t=this.buffers.indices;if(t)this.vertexCount=(t.value||t).length;else if(this.data&&!this.getGeometry)throw new Error("missing indices buffer")}normalizeGeometry(e){if(this.normalize){const t=E(e,this.positionSize);return this.opts.resolution?(0,O.W)(b(t),C(t),{size:this.positionSize,gridResolution:this.opts.resolution,edgeTypes:!0}):this.opts.wrapLongitude?(0,I.G)(b(t),C(t),{size:this.positionSize,maxLatitude:86,edgeTypes:!0}):t}return e}getGeometrySize(e){if(A(e)){let t=0;for(const i of e)t+=this.getGeometrySize(i);return t}return b(e).length/this.positionSize}getGeometryFromBuffer(e){return this.normalize||!this.buffers.indices?super.getGeometryFromBuffer(e):null}updateGeometryAttributes(e,t){if(e&&A(e))for(const i of e){const e=this.getGeometrySize(i);t.geometrySize=e,this.updateGeometryAttributes(i,t),t.vertexStart+=e,t.indexStart=this.indexStarts[t.geometryIndex+1]}else this._updateIndices(e,t),this._updatePositions(e,t),this._updateVertexValid(e,t)}_updateIndices(e,t){let{geometryIndex:i,vertexStart:n,indexStart:o}=t;const{attributes:s,indexStarts:r,typedArrayManager:a}=this;let l=s.indices;if(!l||!e)return;let c=o;const d=function(e,t,i){let n=C(e);n&&(n=n.map((e=>e/t)));let o=b(e);if(i){const e=o.length;o=o.slice();const n=[];for(let s=0;s<e;s+=t){n[0]=o[s],n[1]=o[s+1];const e=i(n);o[s]=e[0],o[s+1]=e[1]}}return v()(o,n,t)}(e,this.positionSize,this.opts.preproject);l=a.allocate(l,o+d.length,{copy:!0});for(let e=0;e<d.length;e++)l[c++]=d[e]+n;r[i+1]=o+d.length,s.indices=l}_updatePositions(e,t){let{vertexStart:i,geometrySize:n}=t;const{attributes:{positions:o},positionSize:s}=this;if(!o||!e)return;const r=b(e);for(let e=i,t=0;t<n;e++,t++){const i=r[t*s],n=r[t*s+1],a=s>2?r[t*s+2]:0;o[3*e]=i,o[3*e+1]=n,o[3*e+2]=a}}_updateVertexValid(e,t){let{vertexStart:i,geometrySize:n}=t;const{positionSize:o}=this,s=this.attributes.vertexValid,r=e&&C(e);if(e&&e.edgeTypes?s.set(e.edgeTypes,i):s.fill(1,i,i+n),r)for(let e=0;e<r.length;e++)s[i+r[e]/o-1]=0;s[i+n-1]=0}}function A(e){return Array.isArray(e)&&e.length>0&&!Number.isFinite(e[0])}const R="\nattribute vec2 vertexPositions;\nattribute float vertexValid;\n\nuniform bool extruded;\nuniform bool isWireframe;\nuniform float elevationScale;\nuniform float opacity;\n\nvarying vec4 vColor;\n\nstruct PolygonProps {\n  vec4 fillColors;\n  vec4 lineColors;\n  vec3 positions;\n  vec3 nextPositions;\n  vec3 pickingColors;\n  vec3 positions64Low;\n  vec3 nextPositions64Low;\n  float elevations;\n};\n\nvec3 project_offset_normal(vec3 vector) {\n  if (project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT ||\n    project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSETS) {\n    // normals generated by the polygon tesselator are in lnglat offsets instead of meters\n    return normalize(vector * project_uCommonUnitsPerWorldUnit);\n  }\n  return project_normal(vector);\n}\n\nvoid calculatePosition(PolygonProps props) {\n#ifdef IS_SIDE_VERTEX\n  if(vertexValid < 0.5){\n    gl_Position = vec4(0.);\n    return;\n  }\n#endif\n\n  vec3 pos;\n  vec3 pos64Low;\n  vec3 normal;\n  vec4 colors = isWireframe ? props.lineColors : props.fillColors;\n\n  geometry.worldPosition = props.positions;\n  geometry.worldPositionAlt = props.nextPositions;\n  geometry.pickingColor = props.pickingColors;\n\n#ifdef IS_SIDE_VERTEX\n  pos = mix(props.positions, props.nextPositions, vertexPositions.x);\n  pos64Low = mix(props.positions64Low, props.nextPositions64Low, vertexPositions.x);\n#else\n  pos = props.positions;\n  pos64Low = props.positions64Low;\n#endif\n\n  if (extruded) {\n    pos.z += props.elevations * vertexPositions.y * elevationScale;\n  }\n  gl_Position = project_position_to_clipspace(pos, pos64Low, vec3(0.), geometry.position);\n\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n\n  if (extruded) {\n  #ifdef IS_SIDE_VERTEX\n    normal = vec3(\n      props.positions.y - props.nextPositions.y + (props.positions64Low.y - props.nextPositions64Low.y),\n      props.nextPositions.x - props.positions.x + (props.nextPositions64Low.x - props.positions64Low.x),\n      0.0);\n    normal = project_offset_normal(normal);\n  #else\n    normal = project_normal(vec3(0.0, 0.0, 1.0));\n  #endif\n    geometry.normal = normal;\n    vec3 lightColor = lighting_getLightColor(colors.rgb, project_uCameraPosition, geometry.position.xyz, normal);\n    vColor = vec4(lightColor, colors.a * opacity);\n  } else {\n    vColor = vec4(colors.rgb, colors.a * opacity);\n  }\n  DECKGL_FILTER_COLOR(vColor, geometry);\n}\n",F="#define SHADER_NAME solid-polygon-layer-vertex-shader\n\nattribute vec3 positions;\nattribute vec3 positions64Low;\nattribute float elevations;\nattribute vec4 fillColors;\nattribute vec4 lineColors;\nattribute vec3 pickingColors;\n\n".concat(R,"\n\nvoid main(void) {\n  PolygonProps props;\n\n  props.positions = positions;\n  props.positions64Low = positions64Low;\n  props.elevations = elevations;\n  props.fillColors = fillColors;\n  props.lineColors = lineColors;\n  props.pickingColors = pickingColors;\n\n  calculatePosition(props);\n}\n"),D="#define SHADER_NAME solid-polygon-layer-vertex-shader-side\n#define IS_SIDE_VERTEX\n\n\nattribute vec3 instancePositions;\nattribute vec3 nextPositions;\nattribute vec3 instancePositions64Low;\nattribute vec3 nextPositions64Low;\nattribute float instanceElevations;\nattribute vec4 instanceFillColors;\nattribute vec4 instanceLineColors;\nattribute vec3 instancePickingColors;\n\n".concat(R,"\n\nvoid main(void) {\n  PolygonProps props;\n\n  #if RING_WINDING_ORDER_CW == 1\n    props.positions = instancePositions;\n    props.positions64Low = instancePositions64Low;\n    props.nextPositions = nextPositions;\n    props.nextPositions64Low = nextPositions64Low;\n  #else\n    props.positions = nextPositions;\n    props.positions64Low = nextPositions64Low;\n    props.nextPositions = instancePositions;\n    props.nextPositions64Low = instancePositions64Low;\n  #endif\n  props.elevations = instanceElevations;\n  props.fillColors = instanceFillColors;\n  props.lineColors = instanceLineColors;\n  props.pickingColors = instancePickingColors;\n\n  calculatePosition(props);\n}\n"),z=[0,0,0,255],k={filled:!0,extruded:!1,wireframe:!1,_normalize:!0,_windingOrder:"CW",elevationScale:{type:"number",min:0,value:1},getPolygon:{type:"accessor",value:e=>e.polygon},getElevation:{type:"accessor",value:1e3},getFillColor:{type:"accessor",value:z},getLineColor:{type:"accessor",value:z},material:!0},W={enter:(e,t)=>t.length?t.subarray(t.length-e.length):e};class N extends a.Z{constructor(){super(...arguments),(0,n.Z)(this,"state",void 0)}getShaders(e){return super.getShaders({vs:"top"===e?F:D,fs:"#define SHADER_NAME solid-polygon-layer-fragment-shader\n\nprecision highp float;\n\nvarying vec4 vColor;\n\nvoid main(void) {\n  gl_FragColor = vColor;\n\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n",defines:{RING_WINDING_ORDER_CW:this.props._normalize||"CCW"!==this.props._windingOrder?1:0},modules:[l.Z,c.N,d.Z]})}get wrapLongitude(){return!1}initializeState(){const{gl:e,viewport:t}=this.context;let{coordinateSystem:i}=this.props;t.isGeospatial&&i===u.Df.DEFAULT&&(i=u.Df.LNGLAT),this.setState({numInstances:0,polygonTesselator:new M({preproject:i===u.Df.LNGLAT&&t.projectFlat.bind(t),fp64:this.use64bitPositions(),IndexType:!e||(0,h.ag)(e,p.h.ELEMENT_INDEX_UINT32)?Uint32Array:Uint16Array})});const n=this.getAttributeManager(),o=!0;n.remove(["instancePickingColors"]),n.add({indices:{size:1,isIndexed:!0,update:this.calculateIndices,noAlloc:o},positions:{size:3,type:5130,fp64:this.use64bitPositions(),transition:W,accessor:"getPolygon",update:this.calculatePositions,noAlloc:o,shaderAttributes:{positions:{vertexOffset:0,divisor:0},instancePositions:{vertexOffset:0,divisor:1},nextPositions:{vertexOffset:1,divisor:1}}},vertexValid:{size:1,divisor:1,type:5121,update:this.calculateVertexValid,noAlloc:o},elevations:{size:1,transition:W,accessor:"getElevation",shaderAttributes:{elevations:{divisor:0},instanceElevations:{divisor:1}}},fillColors:{size:this.props.colorFormat.length,type:5121,normalized:!0,transition:W,accessor:"getFillColor",defaultValue:z,shaderAttributes:{fillColors:{divisor:0},instanceFillColors:{divisor:1}}},lineColors:{size:this.props.colorFormat.length,type:5121,normalized:!0,transition:W,accessor:"getLineColor",defaultValue:z,shaderAttributes:{lineColors:{divisor:0},instanceLineColors:{divisor:1}}},pickingColors:{size:3,type:5121,accessor:(e,t)=>{let{index:i,target:n}=t;return this.encodePickingColor(e&&e.__source?e.__source.index:i,n)},shaderAttributes:{pickingColors:{divisor:0},instancePickingColors:{divisor:1}}}})}getPickingInfo(e){const t=super.getPickingInfo(e),{index:i}=t,{data:n}=this.props;return n[0]&&n[0].__source&&(t.object=n.find((e=>e.__source.index===i))),t}disablePickingIndex(e){const{data:t}=this.props;if(t[0]&&t[0].__source)for(let i=0;i<t.length;i++)t[i].__source.index===e&&this._disablePickingIndex(i);else this._disablePickingIndex(e)}draw(e){let{uniforms:t}=e;const{extruded:i,filled:n,wireframe:o,elevationScale:s}=this.props,{topModel:r,sideModel:a,polygonTesselator:l}=this.state,c={...t,extruded:Boolean(i),elevationScale:s};a&&(a.setInstanceCount(l.instanceCount-1),a.setUniforms(c),o&&(a.setDrawMode(3),a.setUniforms({isWireframe:!0}).draw()),n&&(a.setDrawMode(6),a.setUniforms({isWireframe:!1}).draw())),r&&(r.setVertexCount(l.vertexCount),r.setUniforms(c).draw())}updateState(e){super.updateState(e),this.updateGeometry(e);const{props:t,oldProps:i,changeFlags:n}=e,o=this.getAttributeManager();var s;(n.extensionsChanged||t.filled!==i.filled||t.extruded!==i.extruded)&&(null===(s=this.state.models)||void 0===s||s.forEach((e=>e.delete())),this.setState(this._getModels(this.context.gl)),o.invalidateAll())}updateGeometry(e){let{props:t,oldProps:i,changeFlags:n}=e;if(n.dataChanged||n.updateTriggersChanged&&(n.updateTriggersChanged.all||n.updateTriggersChanged.getPolygon)){const{polygonTesselator:e}=this.state,i=t.data.attributes||{};e.updateGeometry({data:t.data,normalize:t._normalize,geometryBuffer:i.getPolygon,buffers:i,getGeometry:t.getPolygon,positionFormat:t.positionFormat,wrapLongitude:t.wrapLongitude,resolution:this.context.viewport.resolution,fp64:this.use64bitPositions(),dataChanged:n.dataChanged}),this.setState({numInstances:e.instanceCount,startIndices:e.vertexStarts}),n.dataChanged||this.getAttributeManager().invalidateAll()}}_getModels(e){const{id:t,filled:i,extruded:n}=this.props;let o,s;if(i){const i=this.getShaders("top");i.defines.NON_INSTANCED_MODEL=1,o=new g.Z(e,{...i,id:"".concat(t,"-top"),drawMode:4,attributes:{vertexPositions:new Float32Array([0,1])},uniforms:{isWireframe:!1,isSideVertex:!1},vertexCount:0,isIndexed:!0})}return n&&(s=new g.Z(e,{...this.getShaders("side"),id:"".concat(t,"-side"),geometry:new f.Z({drawMode:1,vertexCount:4,attributes:{vertexPositions:{size:2,value:new Float32Array([1,0,0,0,0,1,1,1])}}}),instanceCount:0,isInstanced:1}),s.userData.excludeAttributes={indices:!0}),{models:[s,o].filter(Boolean),topModel:o,sideModel:s}}calculateIndices(e){const{polygonTesselator:t}=this.state;e.startIndices=t.indexStarts,e.value=t.get("indices")}calculatePositions(e){const{polygonTesselator:t}=this.state;e.startIndices=t.vertexStarts,e.value=t.get("positions")}calculateVertexValid(e){e.value=this.state.polygonTesselator.get("vertexValid")}}(0,n.Z)(N,"defaultProps",k),(0,n.Z)(N,"layerName","SolidPolygonLayer");var G=i(75109);const j=[0,0,0,255],B={stroked:!0,filled:!0,extruded:!1,elevationScale:1,wireframe:!1,_normalize:!0,_windingOrder:"CW",lineWidthUnits:"meters",lineWidthScale:1,lineWidthMinPixels:0,lineWidthMaxPixels:Number.MAX_SAFE_INTEGER,lineJointRounded:!1,lineMiterLimit:4,getPolygon:{type:"accessor",value:e=>e.polygon},getFillColor:{type:"accessor",value:[0,0,0,255]},getLineColor:{type:"accessor",value:j},getLineWidth:{type:"accessor",value:1},getElevation:{type:"accessor",value:1e3},material:!0};class U extends o.Z{initializeState(){this.state={paths:[]},this.props.getLineDashArray&&s.Z.removed("getLineDashArray","PathStyleExtension")()}updateState(e){let{changeFlags:t}=e;const i=t.dataChanged||t.updateTriggersChanged&&(t.updateTriggersChanged.all||t.updateTriggersChanged.getPolygon);if(i&&Array.isArray(t.dataChanged)){const e=this.state.paths.slice(),i=t.dataChanged.map((t=>function(e){let{data:t,getIndex:i,dataRange:n,replace:o}=e;const{startRow:s=0,endRow:r=1/0}=n,a=t.length;let l=a,c=a;for(let e=0;e<a;e++){const n=i(t[e]);if(l>e&&n>=s&&(l=e),n>=r){c=e;break}}let d=l;const u=c-l!==o.length?t.slice(c):void 0;for(let e=0;e<o.length;e++)t[d++]=o[e];if(u){for(let e=0;e<u.length;e++)t[d++]=u[e];t.length=d}return{startRow:l,endRow:l+o.length}}({data:e,getIndex:e=>e.__source.index,dataRange:t,replace:this._getPaths(t)})));this.setState({paths:e,pathsDiff:i})}else i&&this.setState({paths:this._getPaths(),pathsDiff:null})}_getPaths(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const{data:t,getPolygon:i,positionFormat:n,_normalize:o}=this.props,s=[],a="XY"===n?2:3,{startRow:l,endRow:c}=e,{iterable:d,objectInfo:u}=(0,r.jB)(t,l,c);for(const e of d){u.index++;let t=i(e,u);o&&(t=E(t,a));const{holeIndices:n}=t,r=t.positions||t;if(n)for(let t=0;t<=n.length;t++){const i=r.slice(n[t-1]||0,n[t]||r.length);s.push(this.getSubLayerRow({path:i},e,u.index))}else s.push(this.getSubLayerRow({path:r},e,u.index))}return s}renderLayers(){const{data:e,_dataDiff:t,stroked:i,filled:n,extruded:o,wireframe:s,_normalize:r,_windingOrder:a,elevationScale:l,transitions:c,positionFormat:d}=this.props,{lineWidthUnits:u,lineWidthScale:h,lineWidthMinPixels:p,lineWidthMaxPixels:g,lineJointRounded:f,lineMiterLimit:m,lineDashJustified:v}=this.props,{getFillColor:y,getLineColor:P,getLineWidth:x,getLineDashArray:w,getElevation:b,getPolygon:C,updateTriggers:S,material:L}=this.props,{paths:_,pathsDiff:E}=this.state,T=this.getSubLayerClass("fill",N),O=this.getSubLayerClass("stroke",G.Z),I=this.shouldRenderSubLayer("fill",_)&&new T({_dataDiff:t,extruded:o,elevationScale:l,filled:n,wireframe:s,_normalize:r,_windingOrder:a,getElevation:b,getFillColor:y,getLineColor:o&&s?P:j,material:L,transitions:c},this.getSubLayerProps({id:"fill",updateTriggers:S&&{getPolygon:S.getPolygon,getElevation:S.getElevation,getFillColor:S.getFillColor,lineColors:o&&s,getLineColor:S.getLineColor}}),{data:e,positionFormat:d,getPolygon:C});return[!o&&I,!o&&i&&this.shouldRenderSubLayer("stroke",_)&&new O({_dataDiff:E&&(()=>E),widthUnits:u,widthScale:h,widthMinPixels:p,widthMaxPixels:g,jointRounded:f,miterLimit:m,dashJustified:v,_pathType:"loop",transitions:c&&{getWidth:c.getLineWidth,getColor:c.getLineColor,getPath:c.getPolygon},getColor:this.getSubLayerAccessor(P),getWidth:this.getSubLayerAccessor(x),getDashArray:this.getSubLayerAccessor(w)},this.getSubLayerProps({id:"stroke",updateTriggers:S&&{getWidth:S.getLineWidth,getColor:S.getLineColor,getDashArray:S.getLineDashArray}}),{data:_,positionFormat:d,getPath:e=>e.path}),o&&I]}}(0,n.Z)(U,"layerName","PolygonLayer"),(0,n.Z)(U,"defaultProps",B)},15087:(e,t,i)=>{"use strict";i.d(t,{Z:()=>h});var n=i(97455),o=i(51007),s=i(17731),r=i(57891),a=i(93742),l=i(55478),c=i(62492);const d=[0,0,0,255],u={radiusUnits:"meters",radiusScale:{type:"number",min:0,value:1},radiusMinPixels:{type:"number",min:0,value:0},radiusMaxPixels:{type:"number",min:0,value:Number.MAX_SAFE_INTEGER},lineWidthUnits:"meters",lineWidthScale:{type:"number",min:0,value:1},lineWidthMinPixels:{type:"number",min:0,value:0},lineWidthMaxPixels:{type:"number",min:0,value:Number.MAX_SAFE_INTEGER},stroked:!1,filled:!0,billboard:!1,antialiasing:!0,getPosition:{type:"accessor",value:e=>e.position},getRadius:{type:"accessor",value:1},getFillColor:{type:"accessor",value:d},getLineColor:{type:"accessor",value:d},getLineWidth:{type:"accessor",value:1},strokeWidth:{deprecatedFor:"getLineWidth"},outline:{deprecatedFor:"stroked"},getColor:{deprecatedFor:["getFillColor","getLineColor"]}};class h extends o.Z{getShaders(){return super.getShaders({vs:"#define SHADER_NAME scatterplot-layer-vertex-shader\n\nattribute vec3 positions;\n\nattribute vec3 instancePositions;\nattribute vec3 instancePositions64Low;\nattribute float instanceRadius;\nattribute float instanceLineWidths;\nattribute vec4 instanceFillColors;\nattribute vec4 instanceLineColors;\nattribute vec3 instancePickingColors;\n\nuniform float opacity;\nuniform float radiusScale;\nuniform float radiusMinPixels;\nuniform float radiusMaxPixels;\nuniform float lineWidthScale;\nuniform float lineWidthMinPixels;\nuniform float lineWidthMaxPixels;\nuniform float stroked;\nuniform bool filled;\nuniform bool antialiasing;\nuniform bool billboard;\nuniform int radiusUnits;\nuniform int lineWidthUnits;\n\nvarying vec4 vFillColor;\nvarying vec4 vLineColor;\nvarying vec2 unitPosition;\nvarying float innerUnitRadius;\nvarying float outerRadiusPixels;\n\n\nvoid main(void) {\n  geometry.worldPosition = instancePositions;\n\n  // Multiply out radius and clamp to limits\n  outerRadiusPixels = clamp(\n    project_size_to_pixel(radiusScale * instanceRadius, radiusUnits),\n    radiusMinPixels, radiusMaxPixels\n  );\n  \n  // Multiply out line width and clamp to limits\n  float lineWidthPixels = clamp(\n    project_size_to_pixel(lineWidthScale * instanceLineWidths, lineWidthUnits),\n    lineWidthMinPixels, lineWidthMaxPixels\n  );\n\n  // outer radius needs to offset by half stroke width\n  outerRadiusPixels += stroked * lineWidthPixels / 2.0;\n\n  // Expand geometry to accomodate edge smoothing\n  float edgePadding = antialiasing ? (outerRadiusPixels + SMOOTH_EDGE_RADIUS) / outerRadiusPixels : 1.0;\n\n  // position on the containing square in [-1, 1] space\n  unitPosition = edgePadding * positions.xy;\n  geometry.uv = unitPosition;\n  geometry.pickingColor = instancePickingColors;\n\n  innerUnitRadius = 1.0 - stroked * lineWidthPixels / outerRadiusPixels;\n  \n  if (billboard) {\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.0), geometry.position);\n    vec3 offset = edgePadding * positions * outerRadiusPixels;\n    DECKGL_FILTER_SIZE(offset, geometry);\n    gl_Position.xy += project_pixel_size_to_clipspace(offset.xy);\n  } else {\n    vec3 offset = edgePadding * positions * project_pixel_size(outerRadiusPixels);\n    DECKGL_FILTER_SIZE(offset, geometry);\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, offset, geometry.position);\n  }\n\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n\n  // Apply opacity to instance color, or return instance picking color\n  vFillColor = vec4(instanceFillColors.rgb, instanceFillColors.a * opacity);\n  DECKGL_FILTER_COLOR(vFillColor, geometry);\n  vLineColor = vec4(instanceLineColors.rgb, instanceLineColors.a * opacity);\n  DECKGL_FILTER_COLOR(vLineColor, geometry);\n}\n",fs:"#define SHADER_NAME scatterplot-layer-fragment-shader\n\nprecision highp float;\n\nuniform bool filled;\nuniform float stroked;\nuniform bool antialiasing;\n\nvarying vec4 vFillColor;\nvarying vec4 vLineColor;\nvarying vec2 unitPosition;\nvarying float innerUnitRadius;\nvarying float outerRadiusPixels;\n\nvoid main(void) {\n  geometry.uv = unitPosition;\n\n  float distToCenter = length(unitPosition) * outerRadiusPixels;\n  float inCircle = antialiasing ? \n    smoothedge(distToCenter, outerRadiusPixels) : \n    step(distToCenter, outerRadiusPixels);\n\n  if (inCircle == 0.0) {\n    discard;\n  }\n\n  if (stroked > 0.5) {\n    float isLine = antialiasing ? \n      smoothedge(innerUnitRadius * outerRadiusPixels, distToCenter) :\n      step(innerUnitRadius * outerRadiusPixels, distToCenter);\n\n    if (filled) {\n      gl_FragColor = mix(vFillColor, vLineColor, isLine);\n    } else {\n      if (isLine == 0.0) {\n        discard;\n      }\n      gl_FragColor = vec4(vLineColor.rgb, vLineColor.a * isLine);\n    }\n  } else if (filled) {\n    gl_FragColor = vFillColor;\n  } else {\n    discard;\n  }\n\n  gl_FragColor.a *= inCircle;\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n",modules:[s.Z,r.Z]})}initializeState(){this.getAttributeManager().addInstanced({instancePositions:{size:3,type:5130,fp64:this.use64bitPositions(),transition:!0,accessor:"getPosition"},instanceRadius:{size:1,transition:!0,accessor:"getRadius",defaultValue:1},instanceFillColors:{size:this.props.colorFormat.length,transition:!0,normalized:!0,type:5121,accessor:"getFillColor",defaultValue:[0,0,0,255]},instanceLineColors:{size:this.props.colorFormat.length,transition:!0,normalized:!0,type:5121,accessor:"getLineColor",defaultValue:[0,0,0,255]},instanceLineWidths:{size:1,transition:!0,accessor:"getLineWidth",defaultValue:1}})}updateState(e){if(super.updateState(e),e.changeFlags.extensionsChanged){var t;const{gl:e}=this.context;null===(t=this.state.model)||void 0===t||t.delete(),this.state.model=this._getModel(e),this.getAttributeManager().invalidateAll()}}draw(e){let{uniforms:t}=e;const{radiusUnits:i,radiusScale:n,radiusMinPixels:o,radiusMaxPixels:s,stroked:r,filled:l,billboard:c,antialiasing:d,lineWidthUnits:u,lineWidthScale:h,lineWidthMinPixels:p,lineWidthMaxPixels:g}=this.props;this.state.model.setUniforms(t).setUniforms({stroked:r?1:0,filled:l,billboard:c,antialiasing:d,radiusUnits:a.iI[i],radiusScale:n,radiusMinPixels:o,radiusMaxPixels:s,lineWidthUnits:a.iI[u],lineWidthScale:h,lineWidthMinPixels:p,lineWidthMaxPixels:g}).draw()}_getModel(e){return new l.Z(e,{...this.getShaders(),id:this.props.id,geometry:new c.Z({drawMode:6,vertexCount:4,attributes:{positions:{size:3,value:new Float32Array([-1,-1,0,1,-1,0,1,1,0,-1,1,0])}}}),isInstanced:!0})}}(0,n.Z)(h,"defaultProps",u),(0,n.Z)(h,"layerName","ScatterplotLayer")},508:(e,t,i)=>{"use strict";var n=i(72007),o=i(633);t.Z=function(e,t,i){void 0===i&&(i={});var s=n.getCoord(e),r=n.getCoord(t),a=o.degreesToRadians(r[1]-s[1]),l=o.degreesToRadians(r[0]-s[0]),c=o.degreesToRadians(s[1]),d=o.degreesToRadians(r[1]),u=Math.pow(Math.sin(a/2),2)+Math.pow(Math.sin(l/2),2)*Math.cos(c)*Math.cos(d);return o.radiansToLength(2*Math.atan2(Math.sqrt(u),Math.sqrt(1-u)),i.units)}},72007:(e,t,i)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n=i(633);t.getCoord=function(e){if(!e)throw new Error("coord is required");if(!Array.isArray(e)){if("Feature"===e.type&&null!==e.geometry&&"Point"===e.geometry.type)return e.geometry.coordinates;if("Point"===e.type)return e.coordinates}if(Array.isArray(e)&&e.length>=2&&!Array.isArray(e[0])&&!Array.isArray(e[1]))return e;throw new Error("coord must be GeoJSON Point or an Array of numbers")},t.getCoords=function(e){if(Array.isArray(e))return e;if("Feature"===e.type){if(null!==e.geometry)return e.geometry.coordinates}else if(e.coordinates)return e.coordinates;throw new Error("coords must be GeoJSON Feature, Geometry Object or an Array")},t.containsNumber=function e(t){if(t.length>1&&n.isNumber(t[0])&&n.isNumber(t[1]))return!0;if(Array.isArray(t[0])&&t[0].length)return e(t[0]);throw new Error("coordinates must only contain numbers")},t.geojsonType=function(e,t,i){if(!t||!i)throw new Error("type and name required");if(!e||e.type!==t)throw new Error("Invalid input to "+i+": must be a "+t+", given "+e.type)},t.featureOf=function(e,t,i){if(!e)throw new Error("No feature passed");if(!i)throw new Error(".featureOf() requires a name");if(!e||"Feature"!==e.type||!e.geometry)throw new Error("Invalid input to "+i+", Feature with geometry required");if(!e.geometry||e.geometry.type!==t)throw new Error("Invalid input to "+i+": must be a "+t+", given "+e.geometry.type)},t.collectionOf=function(e,t,i){if(!e)throw new Error("No featureCollection passed");if(!i)throw new Error(".collectionOf() requires a name");if(!e||"FeatureCollection"!==e.type)throw new Error("Invalid input to "+i+", FeatureCollection required");for(var n=0,o=e.features;n<o.length;n++){var s=o[n];if(!s||"Feature"!==s.type||!s.geometry)throw new Error("Invalid input to "+i+", Feature with geometry required");if(!s.geometry||s.geometry.type!==t)throw new Error("Invalid input to "+i+": must be a "+t+", given "+s.geometry.type)}},t.getGeom=function(e){return"Feature"===e.type?e.geometry:e},t.getType=function(e,t){return"FeatureCollection"===e.type?"FeatureCollection":"GeometryCollection"===e.type?"GeometryCollection":"Feature"===e.type&&null!==e.geometry?e.geometry.type:e.type}},92485:e=>{e.exports=function(e,t,i){var n=null,o=null,s=function(){n&&(clearTimeout(n),o=null,n=null)},r=function(){if(!t)return e.apply(this,arguments);var r=this,a=arguments,l=i&&!n;return s(),o=function(){e.apply(r,a)},n=setTimeout((function(){if(n=null,!l){var e=o;return o=null,e()}}),t),l?o():void 0};return r.cancel=s,r.flush=function(){var e=o;s(),e&&e()},r}},64748:(e,t,i)=>{var n=/^\s+|\s+$/g,o=/^[-+]0x[0-9a-f]+$/i,s=/^0b[01]+$/i,r=/^0o[0-7]+$/i,a=parseInt,l="object"==typeof i.g&&i.g&&i.g.Object===Object&&i.g,c="object"==typeof self&&self&&self.Object===Object&&self,d=l||c||Function("return this")(),u=Object.prototype.toString,h=Math.max,p=Math.min,g=function(){return d.Date.now()};function f(e){var t=typeof e;return!!e&&("object"==t||"function"==t)}function m(e){if("number"==typeof e)return e;if(function(e){return"symbol"==typeof e||function(e){return!!e&&"object"==typeof e}(e)&&"[object Symbol]"==u.call(e)}(e))return NaN;if(f(e)){var t="function"==typeof e.valueOf?e.valueOf():e;e=f(t)?t+"":t}if("string"!=typeof e)return 0===e?e:+e;e=e.replace(n,"");var i=s.test(e);return i||r.test(e)?a(e.slice(2),i?2:8):o.test(e)?NaN:+e}e.exports=function(e,t,i){var n,o,s,r,a,l,c=0,d=!1,u=!1,v=!0;if("function"!=typeof e)throw new TypeError("Expected a function");function y(t){var i=n,s=o;return n=o=void 0,c=t,r=e.apply(s,i)}function P(e){return c=e,a=setTimeout(w,t),d?y(e):r}function x(e){var i=e-l;return void 0===l||i>=t||i<0||u&&e-c>=s}function w(){var e=g();if(x(e))return b(e);a=setTimeout(w,function(e){var i=t-(e-l);return u?p(i,s-(e-c)):i}(e))}function b(e){return a=void 0,v&&n?y(e):(n=o=void 0,r)}function C(){var e=g(),i=x(e);if(n=arguments,o=this,l=e,i){if(void 0===a)return P(l);if(u)return a=setTimeout(w,t),y(l)}return void 0===a&&(a=setTimeout(w,t)),r}return t=m(t)||0,f(i)&&(d=!!i.leading,s=(u="maxWait"in i)?h(m(i.maxWait)||0,t):s,v="trailing"in i?!!i.trailing:v),C.cancel=function(){void 0!==a&&clearTimeout(a),c=0,n=l=o=a=void 0},C.flush=function(){return void 0===a?r:b(g())},C}},37312:(e,t,i)=>{"use strict";i.d(t,{Z:()=>l});var n=i(74369),o=i(80757),s=i(60960);const r=200;class a extends n.Component{constructor(e){var t;super(e),t=this,this.listRef=n.createRef(),this.ghostRef=n.createRef(),this.topOffsets=[],this.itemTranslateOffsets=[],this.initialYOffset=0,this.lastScroll=0,this.lastYOffset=0,this.lastListYOffset=0,this.needle=-1,this.afterIndex=-2,this.state={itemDragged:-1,itemDraggedOutOfBounds:-1,selectedItem:-1,initialX:0,initialY:0,targetX:0,targetY:0,targetHeight:0,targetWidth:0,liveText:"",scrollingSpeed:0,scrollWindow:!1},this.doScrolling=()=>{const{scrollingSpeed:e,scrollWindow:t}=this.state,i=this.listRef.current;window.requestAnimationFrame((()=>{t?window.scrollTo(window.pageXOffset,window.pageYOffset+1.5*e):i.scrollTop+=e,0!==e&&this.doScrolling()}))},this.getChildren=()=>this.listRef&&this.listRef.current?Array.from(this.listRef.current.children):(console.warn("No items found in the List container. Did you forget to pass & spread the `props` param in renderList?"),[]),this.calculateOffsets=()=>{this.topOffsets=this.getChildren().map((e=>e.getBoundingClientRect().top)),this.itemTranslateOffsets=this.getChildren().map((e=>(0,s.yp)(e)))},this.getTargetIndex=e=>this.getChildren().findIndex((t=>t===e.target||t.contains(e.target))),this.onMouseOrTouchStart=e=>{this.dropTimeout&&this.state.itemDragged>-1&&(window.clearTimeout(this.dropTimeout),this.finishDrop());const t=(0,s.z6)(e);if(!t&&0!==e.button)return;const i=this.getTargetIndex(e);if(-1===i||this.props.values[i]&&this.props.values[i].disabled)return void(-1!==this.state.selectedItem&&(this.setState({selectedItem:-1}),this.finishDrop()));const n=this.getChildren()[i],o=n.querySelector("[data-movable-handle]");if((!o||o.contains(e.target))&&!(0,s.W)(e.target,n)){if(e.preventDefault(),this.props.beforeDrag&&this.props.beforeDrag({elements:this.getChildren(),index:i}),t){const e={passive:!1};n.style.touchAction="none",document.addEventListener("touchend",this.schdOnEnd,e),document.addEventListener("touchmove",this.schdOnTouchMove,e),document.addEventListener("touchcancel",this.schdOnEnd,e)}else{document.addEventListener("mousemove",this.schdOnMouseMove),document.addEventListener("mouseup",this.schdOnEnd);const e=this.getChildren()[this.state.itemDragged];e&&e.style&&(e.style.touchAction="")}this.onStart(n,t?e.touches[0].clientX:e.clientX,t?e.touches[0].clientY:e.clientY,i)}},this.getYOffset=()=>{const e=this.listRef.current?this.listRef.current.scrollTop:0;return window.pageYOffset+e},this.onStart=(e,t,i,n)=>{this.state.selectedItem>-1&&(this.setState({selectedItem:-1}),this.needle=-1);const o=e.getBoundingClientRect(),s=window.getComputedStyle(e);this.calculateOffsets(),this.initialYOffset=this.getYOffset(),this.lastYOffset=window.pageYOffset,this.lastListYOffset=this.listRef.current.scrollTop,this.setState({itemDragged:n,targetX:o.left-parseInt(s["margin-left"],10),targetY:o.top-parseInt(s["margin-top"],10),targetHeight:o.height,targetWidth:o.width,initialX:t,initialY:i})},this.onMouseMove=e=>{e.cancelable&&e.preventDefault(),this.onMove(e.clientX,e.clientY)},this.onTouchMove=e=>{e.cancelable&&e.preventDefault(),this.onMove(e.touches[0].clientX,e.touches[0].clientY)},this.onWheel=e=>{this.state.itemDragged<0||(this.lastScroll=this.listRef.current.scrollTop+=e.deltaY,this.moveOtherItems())},this.onMove=(e,t)=>{if(-1===this.state.itemDragged)return null;(0,s.Nb)(this.ghostRef.current,t-this.state.initialY,this.props.lockVertically?0:e-this.state.initialX),this.autoScrolling(t),this.moveOtherItems()},this.moveOtherItems=()=>{const e=this.ghostRef.current.getBoundingClientRect(),t=e.top+e.height/2,i=(0,s.yp)(this.getChildren()[this.state.itemDragged]),n=this.getYOffset();this.initialYOffset!==n&&(this.topOffsets=this.topOffsets.map((e=>e-(n-this.initialYOffset))),this.initialYOffset=n),this.isDraggedItemOutOfBounds()&&this.props.removableByMove?this.afterIndex=this.topOffsets.length+1:this.afterIndex=(0,s.ry)(this.topOffsets,t),this.animateItems(-1===this.afterIndex?0:this.afterIndex,this.state.itemDragged,i)},this.autoScrolling=e=>{const{top:t,bottom:i,height:n}=this.listRef.current.getBoundingClientRect(),o=window.innerHeight||document.documentElement.clientHeight;if(i>o&&o-e<r)this.setState({scrollingSpeed:Math.round((r-(o-e))/10),scrollWindow:!0});else if(t<0&&e<r)this.setState({scrollingSpeed:Math.round((r-e)/-10),scrollWindow:!0});else if(this.state.scrollWindow&&0!==this.state.scrollingSpeed&&this.setState({scrollingSpeed:0,scrollWindow:!1}),n+20<this.listRef.current.scrollHeight){let n=0;e-t<r?n=Math.round((r-(e-t))/-10):i-e<r&&(n=Math.round((r-(i-e))/10)),this.state.scrollingSpeed!==n&&this.setState({scrollingSpeed:n})}},this.animateItems=function(e,i,n){let o=arguments.length>3&&void 0!==arguments[3]&&arguments[3];t.getChildren().forEach(((r,a)=>{if((0,s.Hk)(r,t.props.transitionDuration),i===a&&o){if(i===e)return(0,s.Nb)(r,null);(0,s.Nb)(r,i<e?t.itemTranslateOffsets.slice(i+1,e+1).reduce(((e,t)=>e+t),0):-1*t.itemTranslateOffsets.slice(e,i).reduce(((e,t)=>e+t),0))}else i<e&&a>i&&a<=e?(0,s.Nb)(r,-n):a<i&&i>e&&a>=e?(0,s.Nb)(r,n):(0,s.Nb)(r,null)}))},this.isDraggedItemOutOfBounds=()=>{const e=this.getChildren()[this.state.itemDragged].getBoundingClientRect(),t=this.ghostRef.current.getBoundingClientRect();return Math.abs(e.left-t.left)>t.width?(-1===this.state.itemDraggedOutOfBounds&&this.setState({itemDraggedOutOfBounds:this.state.itemDragged}),!0):(this.state.itemDraggedOutOfBounds>-1&&this.setState({itemDraggedOutOfBounds:-1}),!1)},this.onEnd=e=>{e.cancelable&&e.preventDefault(),document.removeEventListener("mousemove",this.schdOnMouseMove),document.removeEventListener("touchmove",this.schdOnTouchMove),document.removeEventListener("mouseup",this.schdOnEnd),document.removeEventListener("touchup",this.schdOnEnd),document.removeEventListener("touchcancel",this.schdOnEnd);const t=this.props.removableByMove&&this.isDraggedItemOutOfBounds();!t&&this.props.transitionDuration>0&&-2!==this.afterIndex&&(0,s.gF)((()=>{(0,s.Hk)(this.ghostRef.current,this.props.transitionDuration,"cubic-bezier(.2,1,.1,1)"),this.afterIndex<1&&0===this.state.itemDragged?(0,s.Nb)(this.ghostRef.current,0,0):(0,s.Nb)(this.ghostRef.current,-(window.pageYOffset-this.lastYOffset)-(this.listRef.current.scrollTop-this.lastListYOffset)+(this.state.itemDragged<this.afterIndex?this.itemTranslateOffsets.slice(this.state.itemDragged+1,this.afterIndex+1).reduce(((e,t)=>e+t),0):-1*this.itemTranslateOffsets.slice(this.afterIndex<0?0:this.afterIndex,this.state.itemDragged).reduce(((e,t)=>e+t),0)),0)}))(),this.dropTimeout=window.setTimeout(this.finishDrop,t||-2===this.afterIndex?0:this.props.transitionDuration)},this.finishDrop=()=>{const e=this.props.removableByMove&&this.isDraggedItemOutOfBounds();(e||this.afterIndex>-2&&this.state.itemDragged!==this.afterIndex)&&this.props.onChange({oldIndex:this.state.itemDragged,newIndex:e?-1:Math.max(this.afterIndex,0),targetRect:this.ghostRef.current.getBoundingClientRect()}),this.getChildren().forEach((e=>{(0,s.Hk)(e,0),(0,s.Nb)(e,null),e.style.touchAction=""})),this.setState({itemDragged:-1,scrollingSpeed:0}),this.afterIndex=-2,this.lastScroll>0&&(this.listRef.current.scrollTop=this.lastScroll,this.lastScroll=0)},this.onKeyDown=e=>{const t=this.state.selectedItem,i=this.getTargetIndex(e);if(!(0,s.W)(e.target,e.currentTarget)&&-1!==i){if(" "===e.key&&(e.preventDefault(),t===i?(t!==this.needle&&(this.getChildren().forEach((e=>{(0,s.Hk)(e,0),(0,s.Nb)(e,null)})),this.props.onChange({oldIndex:t,newIndex:this.needle,targetRect:this.getChildren()[this.needle].getBoundingClientRect()}),this.getChildren()[this.needle].focus()),this.setState({selectedItem:-1,liveText:this.props.voiceover.dropped(t+1,this.needle+1)}),this.needle=-1):(this.setState({selectedItem:i,liveText:this.props.voiceover.lifted(i+1)}),this.needle=i,this.calculateOffsets())),("ArrowDown"===e.key||"j"===e.key)&&t>-1&&this.needle<this.props.values.length-1){e.preventDefault();const i=(0,s.yp)(this.getChildren()[t]);this.needle++,this.animateItems(this.needle,t,i,!0),this.setState({liveText:this.props.voiceover.moved(this.needle+1,!1)})}if(("ArrowUp"===e.key||"k"===e.key)&&t>-1&&this.needle>0){e.preventDefault();const i=(0,s.yp)(this.getChildren()[t]);this.needle--,this.animateItems(this.needle,t,i,!0),this.setState({liveText:this.props.voiceover.moved(this.needle+1,!0)})}"Escape"===e.key&&t>-1&&(this.getChildren().forEach((e=>{(0,s.Hk)(e,0),(0,s.Nb)(e,null)})),this.setState({selectedItem:-1,liveText:this.props.voiceover.canceled(t+1)}),this.needle=-1),("Tab"===e.key||"Enter"===e.key)&&t>-1&&e.preventDefault()}},this.schdOnMouseMove=(0,s.gF)(this.onMouseMove),this.schdOnTouchMove=(0,s.gF)(this.onTouchMove),this.schdOnEnd=(0,s.gF)(this.onEnd)}componentDidMount(){this.calculateOffsets(),document.addEventListener("touchstart",this.onMouseOrTouchStart,{passive:!1,capture:!1}),document.addEventListener("mousedown",this.onMouseOrTouchStart)}componentDidUpdate(e,t){t.scrollingSpeed!==this.state.scrollingSpeed&&0===t.scrollingSpeed&&this.doScrolling()}componentWillUnmount(){document.removeEventListener("touchstart",this.onMouseOrTouchStart),document.removeEventListener("mousedown",this.onMouseOrTouchStart),this.dropTimeout&&window.clearTimeout(this.dropTimeout),this.schdOnMouseMove.cancel(),this.schdOnTouchMove.cancel(),this.schdOnEnd.cancel()}render(){const e={userSelect:"none",WebkitUserSelect:"none",MozUserSelect:"none",msUserSelect:"none",boxSizing:"border-box",position:"relative"},t={...e,top:this.state.targetY,left:this.state.targetX,width:this.state.targetWidth,height:this.state.targetHeight,position:"fixed",marginTop:0};return n.createElement(n.Fragment,null,this.props.renderList({children:this.props.values.map(((t,i)=>{const n=i===this.state.itemDragged,o=i===this.state.selectedItem,s={key:i,tabIndex:this.props.values[i]&&this.props.values[i].disabled?-1:0,"aria-roledescription":this.props.voiceover.item(i+1),onKeyDown:this.onKeyDown,style:{...e,visibility:n?"hidden":void 0,zIndex:o?5e3:0}};return this.props.renderItem({value:t,props:s,index:i,isDragged:!1,isSelected:o,isOutOfBounds:!1})})),isDragged:this.state.itemDragged>-1,props:{ref:this.listRef}}),this.state.itemDragged>-1&&o.createPortal(this.props.renderItem({value:this.props.values[this.state.itemDragged],props:{ref:this.ghostRef,style:t,onWheel:this.onWheel},index:this.state.itemDragged,isDragged:!0,isSelected:!1,isOutOfBounds:this.state.itemDraggedOutOfBounds>-1}),this.props.container||document.body),n.createElement("div",{"aria-live":"assertive",role:"log","aria-atomic":"true",style:{position:"absolute",width:"1px",height:"1px",margin:"-1px",border:"0px",padding:"0px",overflow:"hidden",clip:"rect(0px, 0px, 0px, 0px)",clipPath:"inset(100%)"}},this.state.liveText))}}a.defaultProps={transitionDuration:300,lockVertically:!1,removableByMove:!1,voiceover:{item:e=>"You are currently at a draggable item at position ".concat(e,". Press space bar to lift."),lifted:e=>"You have lifted item at position ".concat(e,". Press j to move down, k to move up, space bar to drop and escape to cancel."),moved:(e,t)=>"You have moved the lifted item ".concat(t?"up":"down"," to position ").concat(e,". Press j to move down, k to move up, space bar to drop and escape to cancel."),dropped:(e,t)=>"You have dropped the item. It has moved from position ".concat(e," to ").concat(t,"."),canceled:e=>"You have cancelled the movement. The item has returned to its starting position of ".concat(e,".")}};const l=a},60960:(e,t,i)=>{"use strict";function n(e,t,i){return(e=e.slice()).splice(i<0?e.length+i:i,0,e.splice(t,1)[0]),e}function o(e){const t=window.getComputedStyle(e);return Math.max(parseInt(t["margin-top"],10),parseInt(t["margin-bottom"],10))+e.getBoundingClientRect().height}function s(e){return e.touches&&e.touches.length||e.changedTouches&&e.changedTouches.length}function r(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;e&&(null!==t&&null!==i?e.style.transform="translate(".concat(i,"px, ").concat(t,"px)"):e.style.removeProperty("transform"))}function a(e,t,i){e&&(e.style.transition="transform ".concat(t,"ms").concat(i?" ".concat(i):""))}function l(e,t){let i,n=0,o=e.length-1;for(;n<=o;){if(i=Math.floor((o+n)/2),!e[i+1]||e[i]<=t&&e[i+1]>=t)return i;e[i]<t&&e[i+1]<t?n=i+1:o=i-1}return-1}i.d(t,{Hk:()=>a,Nb:()=>r,Rp:()=>n,W:()=>d,gF:()=>c,ry:()=>l,yp:()=>o,z6:()=>s});const c=e=>{let t=[],i=null;const n=function(){for(var n=arguments.length,o=new Array(n),s=0;s<n;s++)o[s]=arguments[s];t=o,i||(i=requestAnimationFrame((()=>{i=null,e(...t)})))};return n.cancel=()=>{i&&cancelAnimationFrame(i)},n};function d(e,t){const i=["input","textarea","select","option","optgroup","video","audio","button","a"],n=["button","link","checkbox","tab"];for(;e!==t;){if(e.getAttribute("data-movable-handle"))return!1;if(i.includes(e.tagName.toLowerCase()))return!0;const t=e.getAttribute("role");if(t&&n.includes(t.toLowerCase()))return!0;if("label"===e.tagName.toLowerCase()&&e.hasAttribute("for"))return!0;e.tagName&&(e=e.parentElement)}return!1}},21697:(e,t,i)=>{"use strict";i.d(t,{DL:()=>a,Ht:()=>l,Tu:()=>r,zL:()=>s});var n=6371008.8,o={centimeters:637100880,centimetres:637100880,degrees:57.22891354143274,feet:20902260.511392,inches:39.37*n,kilometers:6371.0088,kilometres:6371.0088,meters:n,metres:n,miles:3958.761333810546,millimeters:6371008800,millimetres:6371008800,nauticalmiles:n/1852,radians:1,yards:6967335.223679999};function s(e,t,i){void 0===i&&(i={});var n={type:"Feature"};return(0===i.id||i.id)&&(n.id=i.id),i.bbox&&(n.bbox=i.bbox),n.properties=t||{},n.geometry=e,n}function r(e,t,i){if(void 0===i&&(i={}),e.length<2)throw new Error("coordinates must be an array of two or more positions");return s({type:"LineString",coordinates:e},t,i)}function a(e,t){void 0===t&&(t="kilometers");var i=o[t];if(!i)throw new Error(t+" units is invalid");return e*i}function l(e){return e%360*Math.PI/180}},4520:(e,t,i)=>{"use strict";function n(e){if(!e)throw new Error("coord is required");if(!Array.isArray(e)){if("Feature"===e.type&&null!==e.geometry&&"Point"===e.geometry.type)return e.geometry.coordinates;if("Point"===e.type)return e.coordinates}if(Array.isArray(e)&&e.length>=2&&!Array.isArray(e[0])&&!Array.isArray(e[1]))return e;throw new Error("coord must be GeoJSON Point or an Array of numbers")}i.d(t,{Z:()=>d});var o=i(21697);const s=function(e,t,i){void 0===i&&(i={});var s=n(e),r=n(t),a=(0,o.Ht)(r[1]-s[1]),l=(0,o.Ht)(r[0]-s[0]),c=(0,o.Ht)(s[1]),d=(0,o.Ht)(r[1]),u=Math.pow(Math.sin(a/2),2)+Math.pow(Math.sin(l/2),2)*Math.cos(c)*Math.cos(d);return(0,o.DL)(2*Math.atan2(Math.sqrt(u),Math.sqrt(1-u)),i.units)};function r(e,t,i){if(null!==e)for(var n,o,s,a,l,c,d,u,h=0,p=0,g=e.type,f="FeatureCollection"===g,m="Feature"===g,v=f?e.features.length:1,y=0;y<v;y++){l=(u=!!(d=f?e.features[y].geometry:m?e.geometry:e)&&"GeometryCollection"===d.type)?d.geometries.length:1;for(var P=0;P<l;P++){var x=0,w=0;if(null!==(a=u?d.geometries[P]:d)){c=a.coordinates;var b=a.type;switch(h=!i||"Polygon"!==b&&"MultiPolygon"!==b?0:1,b){case null:break;case"Point":if(!1===t(c,p,y,x,w))return!1;p++,x++;break;case"LineString":case"MultiPoint":for(n=0;n<c.length;n++){if(!1===t(c[n],p,y,x,w))return!1;p++,"MultiPoint"===b&&x++}"LineString"===b&&x++;break;case"Polygon":case"MultiLineString":for(n=0;n<c.length;n++){for(o=0;o<c[n].length-h;o++){if(!1===t(c[n][o],p,y,x,w))return!1;p++}"MultiLineString"===b&&x++,"Polygon"===b&&w++}"Polygon"===b&&x++;break;case"MultiPolygon":for(n=0;n<c.length;n++){for(w=0,o=0;o<c[n].length;o++){for(s=0;s<c[n][o].length-h;s++){if(!1===t(c[n][o][s],p,y,x,w))return!1;p++}w++}x++}break;case"GeometryCollection":for(n=0;n<a.geometries.length;n++)if(!1===r(a.geometries[n],t,i))return!1;break;default:throw new Error("Unknown Geometry Type")}}}}}function a(e,t){var i,n,o,s,r,a,l,c,d,u,h=0,p="FeatureCollection"===e.type,g="Feature"===e.type,f=p?e.features.length:1;for(i=0;i<f;i++){for(a=p?e.features[i].geometry:g?e.geometry:e,c=p?e.features[i].properties:g?e.properties:{},d=p?e.features[i].bbox:g?e.bbox:void 0,u=p?e.features[i].id:g?e.id:void 0,r=(l=!!a&&"GeometryCollection"===a.type)?a.geometries.length:1,o=0;o<r;o++)if(null!==(s=l?a.geometries[o]:a))switch(s.type){case"Point":case"LineString":case"MultiPoint":case"Polygon":case"MultiLineString":case"MultiPolygon":if(!1===t(s,h,c,d,u))return!1;break;case"GeometryCollection":for(n=0;n<s.geometries.length;n++)if(!1===t(s.geometries[n],h,c,d,u))return!1;break;default:throw new Error("Unknown Geometry Type")}else if(!1===t(null,h,c,d,u))return!1;h++}}function l(e,t){a(e,(function(e,i,n,s,r){var a,l=null===e?null:e.type;switch(l){case null:case"Point":case"LineString":case"Polygon":return!1!==t((0,o.zL)(e,n,{bbox:s,id:r}),i,0)&&void 0}switch(l){case"MultiPoint":a="Point";break;case"MultiLineString":a="LineString";break;case"MultiPolygon":a="Polygon"}for(var c=0;c<e.coordinates.length;c++){var d={type:a,coordinates:e.coordinates[c]};if(!1===t((0,o.zL)(d,n),i,c))return!1}}))}function c(e,t,i){var n=i,s=!1;return function(e,t){l(e,(function(e,i,n){var s=0;if(e.geometry){var a=e.geometry.type;if("Point"!==a&&"MultiPoint"!==a){var l,c=0,d=0,u=0;return!1!==r(e,(function(r,a,h,p,g){if(void 0===l||i>c||p>d||g>u)return l=r,c=i,d=p,u=g,void(s=0);var f=(0,o.Tu)([l,r],e.properties);if(!1===t(f,i,n,g,s))return!1;s++,l=r}))&&void 0}}}))}(e,(function(e,o,r,a,l){n=!1===s&&void 0===i?e:t(n,e,o,r,a,l),s=!0})),n}function d(e,t){return void 0===t&&(t={}),c(e,(function(e,i){var n=i.geometry.coordinates;return e+s(n[0],n[1],t)}),0)}}}]);